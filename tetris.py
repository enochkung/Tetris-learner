## decision trees

import pygame
import random

# import json
# import pickle
import numpy as np
from pathlib import Path
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import normalize
from sklearn.neural_network import MLPRegressor
from time import sleep
from learner import Learner, Stats
from board_mechanics import Board

BLACK = (31, 29, 36)
WHITE = (177, 156, 217)  # (255, 255, 255)
pygame.font.init()

"""
running Tetris game where actions are chosen by a learner

Press p to pause game
Press q to quite game

"""


class QTetris:
    def __init__(self):
        self.score = 0
        self.bag = None
        self.gap = 30
        self.width = 10
        self.stat = Stats()
        self.input_record = []
        self.output_record = []
        self.weight_index = 0
        self.weight_perf = []
        self.update_perf = []
        self.update_step = False
        self.game_count = 0
        self.score_rec = 0
        self.alpha = 0.5
        self.gamma = 0.9

        ## initiate learner
        self.learner = Learner()
        self.tetris_learner = self.learner.learner
        ## run game
        self.initiate_game()

    def new_game_init(self):
        self.win = pygame.display.set_mode((500, 690))
        pygame.init()
        pygame.time.set_timer(pygame.USEREVENT, 1000)
        pygame.event.set_blocked(pygame.MOUSEMOTION)
        self.game = True

    def new_run_init(self):
        self.create_board()
        self.win.fill(BLACK)
        self.run = True
        self.score = 0
        self.game_count += 1
        self.lines_cleared = 0
        self.move_count = 0
        self.game_input = []
        self.game_output = []

    def initiate_game(self):
        self.new_game_init()

        while self.game:

            self.new_run_init()

            while self.run:
                ## get action: random or optained by tree
                piece_type, action = self.get_action()
                pre_action_board = self.board.copy()

                ## apply action
                self.apply_action(piece_type, action)
                self.move_count += 1

                ## clear rows
                self.board, self.num_full_lines = self.clear_full_lines(self.board)
                post_action_board = self.board.copy()

                inputs, output = self.learner.update_record(
                    post_action_board, self.num_full_lines, self.game_count
                )
                ## check if game ends
                if np.any(self.board[0:3, :] != 0):

                    output -= 10

                    self.input_record.append(inputs)
                    self.output_record.append(output)

                    self.run = False
                    if self.game_count % 15 == 14:
                        self.learner.updating_model(
                            self.input_record, self.output_record
                        )
                        self.learner.print_model_pred(
                            self.input_record, self.output_record
                        )
                        if len(self.output_record) > 1000:
                            self.remove_old_records()
                else:
                    ## count score
                    output += 1

                    self.input_record.append(inputs)
                    self.output_record.append(output)
                    ## count cleared lines
                    self.lines_cleared += self.num_full_lines
                    ## update board
                    self.display_array_score()

                ## QUIT, PAUSE, LOAD PREVIOUS LEARNING button
                for event in pygame.event.get():
                    if event.type == pygame.KEYDOWN:
                        if event.key == pygame.K_q:
                            self.game = False
                            self.run = False
                        elif event.key == pygame.K_p:
                            self.pause_screen()

    def get_action(self):
        """ get best action """
        ## get next piece
        piece_type = self.get_next_piece()

        ep = random.random()
        if ep < 0.05:
            ## generate random action with 5% probability
            rot = self.move_count % 4
            piece = self.piece_array(piece_type, rot)
            col = (2 * self.move_count) % (10 - piece.shape[1] + 1)
        else:
            ## action generated by learner
            test_board = self.board.copy()
            action_score_pair = self.learner.get_best_action(test_board, piece_type)
            rot = action_score_pair[0][0]
            col = action_score_pair[0][1]

        return piece_type, (rot, col)

    def get_tree_action(self, piece_type):
        """ choose action that generates the highest score given by tree when inputted with """
        predict_score_collection = []
        for rot in range(4):
            piece = self.piece_array(piece_type, rot)
            for col in range(10 - piece.shape[1] + 1):
                """ apply action and then calculate its features, plug into neural network or tree, get score """
                test_board = self.board.copy()
                test_board, _ = self.place_board(test_board, piece_type, (rot, col))
                test_board, full_lines = self.clear_full_lines(test_board)
                test_vector = self.stat.all_stat_in_vector(test_board)
                test_vector.extend([piece_type, rot, col])

                ## apply action
                predict_score = full_lines ** 2 * 10
                predict_score_collection.append((rot, col, predict_score))

        return max(predict_score_collection, key=lambda y: y[2])

    def remove_old_records(self):
        """ remove old half of existing records """

        half_record_size = int(9 * len(self.output_record) / 10)
        del self.input_record[0:half_record_size]
        del self.output_record[0:half_record_size]

    def display_array_score(self):
        self.win.fill(BLACK)
        ## draw boundaries
        pygame.draw.line(self.win, WHITE, (0, 3 * 30), (10 * 30, 3 * 30))
        pygame.draw.line(self.win, WHITE, (10 * 30, 3 * 30), (10 * 30, 23 * 30))
        ## draw blocks
        rows = [x for x in self.board]
        for row_index, row in enumerate(rows):
            for col_index, col in enumerate(row):
                if col != 0 and row_index >= 3:
                    pygame.draw.rect(
                        self.win,
                        WHITE,
                        (
                            col_index * 30,
                            row_index * 30,
                            30,
                            30,
                        ),
                        0,
                    )
        # for row_index, row in enumerate(rows):
        #     for col_index, col in enumerate(row):
        #         if col != 0 and row_index >= 3:
        #             pygame.draw.rect(
        #                 self.win,
        #                 BLACK,
        #                 (
        #                     col_index * 30,
        #                     row_index * 30,
        #                     30,
        #                     30,
        #                 ),
        #                 2,
        #             )
        # Game Count
        font = pygame.font.SysFont("ComicSans", 40)
        text = font.render("Game Count", 1, (255, 255, 255))
        count = font.render(str(self.game_count), 1, (255, 255, 255))
        self.win.blit(text, (self.width * self.gap + int(self.gap / 2), 1 * self.gap))
        self.win.blit(count, (self.width * self.gap + int(self.gap / 2), 2 * self.gap))

        # Write Score
        font = pygame.font.SysFont("ComicSans", 40)
        text = font.render("Lines Cleared", 1, (255, 255, 255))
        score = font.render(str(self.lines_cleared), 1, (255, 255, 255))
        self.win.blit(text, (self.width * self.gap + int(self.gap / 2), 3 * self.gap))
        self.win.blit(score, (self.width * self.gap + int(self.gap / 2), 4 * self.gap))

        font = pygame.font.SysFont("ComicSans", 30)
        text = font.render("Move Count", 1, (255, 255, 255))
        count = font.render(str(self.move_count), 1, (255, 255, 255))
        self.win.blit(text, (self.width * self.gap + int(self.gap / 2), 5 * self.gap))
        self.win.blit(count, (self.width * self.gap + int(self.gap / 2), 6 * self.gap))

        # Write Score
        font = pygame.font.SysFont("ComicSans", 30)
        text = font.render("Dataset Size", 1, (255, 255, 255))
        score = font.render(str(len(self.input_record)), 1, (255, 255, 255))
        self.win.blit(text, (self.width * self.gap + int(self.gap / 2), 7 * self.gap))
        self.win.blit(score, (self.width * self.gap + int(self.gap / 2), 8 * self.gap))

        ## display stats
        font = pygame.font.SysFont("ComicSans", 20)
        holes = font.render("holes: ", 1, (255, 255, 255))
        num_holes = font.render(
            str(self.stat.num_holes(self.board)), 1, (255, 255, 255)
        )
        self.win.blit(holes, (self.width * self.gap + int(self.gap / 2), 16 * self.gap))
        self.win.blit(num_holes, (self.width * self.gap + self.gap * 4, 16 * self.gap))

        holes = font.render("row trans: ", 1, (255, 255, 255))
        num_holes = font.render(
            str(self.stat.row_transition(self.board)), 1, (255, 255, 255)
        )
        self.win.blit(
            holes, (self.width * self.gap + int(self.gap / 2), 16.5 * self.gap)
        )
        self.win.blit(
            num_holes, (self.width * self.gap + self.gap * 4, 16.5 * self.gap)
        )

        holes = font.render("col trans: ", 1, (255, 255, 255))
        num_holes = font.render(
            str(self.stat.col_transition(self.board)), 1, (255, 255, 255)
        )
        self.win.blit(holes, (self.width * self.gap + int(self.gap / 2), 17 * self.gap))
        self.win.blit(num_holes, (self.width * self.gap + self.gap * 4, 17 * self.gap))

        holes = font.render("well sums: ", 1, (255, 255, 255))
        num_holes = font.render(
            str(self.stat.well_sums(self.board)), 1, (255, 255, 255)
        )
        self.win.blit(
            holes, (self.width * self.gap + int(self.gap / 2), 17.5 * self.gap)
        )
        self.win.blit(
            num_holes, (self.width * self.gap + self.gap * 4, 17.5 * self.gap)
        )

        # holes = font.render("landing: ", 1, (255, 255, 255))
        # num_holes = font.render(
        #     str(self.stat.bumpiness(self.board)), 1, (255, 255, 255)
        # )
        # self.win.blit(holes, (self.width * self.gap + int(self.gap / 2), 18 * self.gap))
        # self.win.blit(num_holes, (self.width * self.gap + self.gap * 4, 18 * self.gap))
        pygame.display.update()

    def apply_action(self, piece_type, action):
        """ board array, piece array, rot and col to create new board """
        self.board, _ = self.place_board(self.board, piece_type, action)

    def place_board(self, board, piece_type, action):
        rot = action[0]
        col = action[1]

        ## create piece and push to left edge
        piece = self.piece_array(piece_type, rot)
        piece = self.trim_piece(piece)
        p_shape = piece.shape

        ## place piece in board when possible
        row = 0

        X = board[(row + 1) : (row + 1 + p_shape[0]), col : (col + p_shape[1])] + piece

        while 2 not in X:
            row += 1
            if row + p_shape[0] >= 23:
                break
            X = (
                board[(row + 1) : (row + 1 + p_shape[0]), col : (col + p_shape[1])]
                + piece
            )

        board[row : (row + p_shape[0]), col : (col + p_shape[1])] = (
            board[row : (row + p_shape[0]), col : (col + p_shape[1])] + piece
        )
        return board, row

    def piece_array(self, piece_type, rot):
        if piece_type == 1:
            piece = np.zeros((4, 4))
            piece[1, :] = 1
        elif piece_type == 4:
            piece = np.ones((2, 2))
        else:
            piece = np.zeros((3, 3))
            if piece_type == 2:
                piece[1, :] = 1
                piece[0, 0] = 1
            elif piece_type == 3:
                piece[1, :] = 1
                piece[0, 2] = 1
            elif piece_type == 5:
                piece[0, 1:] = 1
                piece[1, 0:2] = 1
            elif piece_type == 6:
                piece[1, :] = 1
                piece[0, 1] = 1
            elif piece_type == 7:
                piece[0, 0:2] = 1
                piece[1, 1:] = 1

        for rotate in range(rot):
            piece = np.rot90(piece)

        return piece

    def trim_piece(self, piece):
        piece = piece[np.any(piece == 1, axis=1), :]
        piece = piece[:, np.any(piece == 1, axis=0)]
        return piece

    def create_board(self):
        self.board = np.zeros((23, 10))

    def piece_bag(self):
        bag = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7]
        random.shuffle(bag)
        return bag

    def get_next_piece(self):
        if not self.bag:
            self.bag = self.piece_bag()
        piece = self.bag[-1]
        del self.bag[-1]
        return piece

    def clear_full_lines(self, board):
        full_lines = np.where(np.all(board == 1, axis=1))
        num_full_lines = 0

        if full_lines[0].shape[0] != 0:
            if full_lines[0].shape[0] >= 2:
                import pdb

                pdb.set_trace()
            num_full_lines = full_lines[0].shape[0]
            board = np.delete(board, full_lines, axis=0)
            board = np.vstack((np.zeros((num_full_lines, board.shape[1])), board))

        return board, num_full_lines

    def pause_screen(
        self,
    ):
        run = True
        while run:
            for event in pygame.event.get():
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_p:
                        run = False


nsc = QTetris()